Solutions - Deliverable 1
Charlotte Miller & Sebastian Fugle

  For this deliverable, we extended TIP.g4 to add SIP grammar extensions. To ensure that it then worked properly, we created a SIPParserTest class that tested the new features for intended and unintended effects. One of the most difficult aspects of this deliverable was not coding, but working with the unfamiliar tipc code and repository, including figuring out how to configure the set-up and run code. Once we knew how to run code, we began by implementing the SIP changes into TIP.g4. In this part of the project, the most difficult aspects were implementing ternary expressions and arrays. Ternary expressions were difficult because it's not a feature that one of the implementers had utilized in other languages, so it was much more difficult to imagine how it fit into a program. 
  
  Arrays and array features were difficult to implement because of the ambiguity on what the parser should allow. For example, for an array index expression, which looks like arr[index], should the parser accept any expression followed by an array (expr ARRAY), which would include wrong uses like 1[0] or a[0,1], or accept only an id or array followed by '['expr']' ((IDENTIFIER | ARRAY) '[' expr ']'), which would only accept the correct sequences but might put an overburden of processing / narrowing down incorrect programs on the parser that should be implemented later in the program. Ultimately, we chose to list the grammar as expr '[' expr ']' which would accept incorrect expresssions in the form of true[true] but is similar to the other grammar rules. 
  
  Another one of the choices we made in this part of the project was to separate out certain rules with different formatting such as for the for range and the for range with the by option. This was intended to make things easier for us down the line, as they will have to be processed differently even if they are alterations on the same feature. Rather than checking which form it had later down the line, it will be two different types of statements that we can treat differently. After the grammar was implemented for a feature, we proceeded to test that feature. The biggest challenge for this section was to decide what to test, especially for ensuring there weren't statements allowed when they shouldn't have been allowed. To create these tests, we considered the grammar we used and tested mistakes that were close but not quite right, such as an array being allowed that was [0,0,], and edge cases, such as an empty array. This way we made sure that the grammar we implemented was doing what we thought it would.
