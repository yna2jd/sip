Solutions 2 Deliverable Summary
Charlotte Miller & Sebastian Fugle

For our second deliverable, we added all of the new features from deliverable 1 to the ASTBuilder, ASTVisitor, and PrettyPrinter, which meant we first had to add all of our new nodes to the treetypes folder. One of the major obstacles of implementing this code was ensuring continuity between the AST nodes created, the ASTBuilder, ASTVisitor, and PrettyPrinter methods, and the grammar we had enforced. When testing our code, we found many small errors such as a variable name or method name differing from what it was called in one place that crashed our code. For example, in the ASTBuilder, our not expression was referred to as ASTNotExpr, which caused an error as the node was called ASTLogicalNotExpr. In the future, these errors could have been reduced by implementing one node all the way through, testing as you go, instead of implementing all nodes for each step before moving on.

One of the major alternatives we considered was when to combine expressions/statements into one node and when to separate them into separate nodes. Usually, we erred on the side of creating separate nodes, such as for increment and decrement statements (which became ASTIncrStmt and ASTDecrStmt), with our logical behind this being that while it means we have to create more files and methods now, in the next phases of the project it will be nice to be able to handle the nodes separately. Hopefully, this will make the next phase easier for being more straightforward and reducing confusion, even if we have to handle more nodes. For this reason, we separated the operations and, or, and not into their own nodes as well. However, even though we had separated the for by statement and the for by statement with the optional expression in our TIP.g4 file, we ultimately decided to make it into one AST node, because we decided that separating them would increase rather than decrease confusion.

For testing, our goal was to cover every line of code that we wrote. Because it is easy to see visually where a test went wrong by comparing the actual string printed versus the expected, we often tested the output of our code for many expressions or statements in one test. While in other situations this would not be best practice as it could make it difficult to determine what part of the code went wrong, we determined that, because of the ease of visually identifying what part of the code went wrong, testing multiple nodes/methods at once worked well. We ensured that our tests had full coverage across our written code, which gave us confidence that our code worked as intended.
